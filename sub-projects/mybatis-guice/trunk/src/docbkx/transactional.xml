<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!--
    Copyright 2010 The myBatis Team

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->

<!--
    version: $Id$
-->
<chapter id="transactional">
    <title>@Transactional</title>

    <section id="transactional.introduction">
        <title>Introduction</title>
        <para>
            Thanks to the excellent combination between <literal>AOP</literal>
            and Google Guice, users can drastically reduce the boilerplate
            code into their DAOs.
        </para>
        <para>
            Let's take in consideration the following code snippet, written
            without introducing mybatis-guice:
            <programlistingco>
                <areaspec>
                    <area id="transactional.example.openSession" coords="14"/>
                    <area id="transactional.example.getFooMapper" coords="17"/>
                    <area id="transactional.example.getBarMapper" coords="20"/>
                    <area id="transactional.example.commitSession" coords="23"/>
                    <area id="transactional.example.rollbackSession" coords="26"/>
                    <area id="transactional.example.throwCustomException" coords="27"/>
                    <area id="transactional.example.closeSession" coords="29"/>
                </areaspec>
                <programlisting language="java"><![CDATA[package com.acme;

import org.apache.ibatis.session.*;
import org.mybatis.guice.transactional.*;

public final class FooDAO {

    private final SqlSessionManager sessionManager;

    public FooDAO(SqlSessionManager sessionManager) {
        this.sessionManager = sessionManager;
    }

    public void doFooBar() throws MyDaoException {
        this.sessionManager.startManagedSession(ExecutorType.BATCH,
            TransactionIsolationLevel.READ_UNCOMMITTED);
        try {
            FooMapper fooMapper = this.sessionManager.getMapper(FooMapper.class);
            fooMapper.doFoo();

            BarMapper barMapper = this.sessionManager.getMapper(BarMapper.class);
            barMapper.doBar();

            this.sessionManager.commit();
        } catch (Throwable t) {
            this.sessionManager.rollback();
            throw new MyDaoException("Something went wrong", t);
        } finally {
            this.sessionManager.close();
        }
    }

}]]></programlisting>
                <calloutlist>
                    <callout arearefs="transactional.example.openSession">
                        <para>Starts a new <literal>SqlSession</literal>.</para>
                    </callout>
                    <callout arearefs="transactional.example.getFooMapper">
                        <para>Retrieve the <literal>FooMapper</literal> and
                        execute the <literal>doFoo()</literal> method.</para>
                    </callout>
                    <callout arearefs="transactional.example.getBarMapper">
                        <para>Same for the <literal>BarMapper</literal>,
                        retrieved from the SqlSession and executed the
                        <literal>doBar()</literal> method.</para>
                    </callout>
                    <callout arearefs="transactional.example.commitSession">
                        <para>If everything gone fine, commit the open session.</para>
                    </callout>
                    <callout arearefs="transactional.example.rollbackSession">
                        <para>If something gone wrong, rollback the open session.</para>
                    </callout>
                    <callout arearefs="transactional.example.throwCustomException">
                        <para>Optionally, throw a proper DAO layer <literal>Exception</literal>.</para>
                    </callout>
                    <callout arearefs="transactional.example.closeSession">
                        <para>Close the session.</para>
                    </callout>
                </calloutlist>
            </programlistingco>
        </para>
        <para>
            Users can easily note that this is a recursive and redundant code
            pattern that mybatis-guice will help to simplify introducing a
            special <literal>AOP</literal> interceptor.
        </para>
    </section>

    <section id="transactional.annotation">
        <title>The @Transactional annotation</title>
        <para>
            Annottaing methods with the <literal>org.mybatis.guice.transactional.Transactional</literal>
            annotation, users can eliminate recursive code patterns.
        </para>
        <para>
            First of all, let's have a look at the injector thet will create the
            previous <literal>FooDAO</literal> instance:
            <programlisting language="java"><![CDATA[Class<? extends Provider<DataSource>> dataSourceProviderClass = [...];
Class<? extends Provider<TransactionFactory>> txFactoryProviderClass = [...];

Injector injector = Guice.createInjector(
    new MyBatisModule(dataSourceProviderClass, txFactoryProviderClass)
        .addMapperClasses(FooMapper.class, BarMapper.class));
);

FooDAO fooDAO = injector.getInstance(FooDAO.class);]]></programlisting>
        </para>
        <para>
            Where <literal>FooDAO</literal> definition is:
            <programlisting language="java"><![CDATA[package com.acme;

import com.google.inject.*;
import org.apache.ibatis.session.*;
import org.mybatis.guice.transactional.*;

@Singleton
public final class FooDAOImpl {

    @Inject
    private FooMapper fooMapper;

    @Inject
    private BarMapper barMapper;

    // let's assume setters here

    @Transactional(
        executorType = ExecutorType.BATCH,
        isolationLevel = TransactionIsolationLevel.READ_UNCOMMITTED,
        rethrowExceptionsAs = MyDaoException.class,
        exceptionMessage = "Something went wrong"
    )
    public void doFooBar() {
        this.fooMapper.doFoo();
        this.barMapper.doBar();
    }

}]]></programlisting>
        </para>
        <para>
            Users can now simply read how the code can be reduced, delegating
            to the interceptor the session management!
        </para>
        <para>
            The <literal>org.mybatis.guice.transactional.Transactional</literal>
            annotation supports the following parameters:
            <table>
                <caption>org.mybatis.guice.transactional.Transactional properties</caption>
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>autoCommit</td>
                        <td>false</td>
                        <td>the MyBatis auto commit policy</td>
                    </tr>
                    <tr>
                        <td>executorType</td>
                        <td>org.apache.ibatis.session.ExecutorType.SIMPLE</td>
                        <td>the MyBatis executor type</td>
                    </tr>
                    <tr>
                        <td>isolationLevel</td>
                        <td>org.apache.ibatis.session.TransactionIsolationLevel.NONE</td>
                        <td>the transaction isolation level</td>
                    </tr>
                    <tr>
                        <td>force</td>
                        <td>false</td>
                        <td>Flag to indicate that MyBatis has to force the
                        transaction <literal>commit()</literal></td>
                    </tr>
                    <tr>
                        <td>rethrowExceptionsAs</td>
                        <td>Exception.class</td>
                        <td>rethrow caught exceptions as new Exception
                        (maybe a proper layer exception)</td>
                    </tr>
                    <tr>
                        <td>exceptionMessage</td>
                        <td>empty string</td>
                        <td>A custom error message when throwing the custom exception;
                        it supports <literal>java.text.MessageFormat</literal>
                        place holders, intercepted method arguments will be used
                        as message format arguments.</td>
                    </tr>
                </tbody>
            </table>
        </para>
        <para>
            When configuring the <literal>@Transactional</literal> annotation
            take care that if <literal>isolationLevel()</literal>
            is equals to <literal>TransactionIsolationLevel.NONE</literal>,
            then the <literal>SqlSession</literal>
            will be started using the <literal>executorType()</literal>
            and <literal>autoCommit()</literal> values.
        </para>
    </section>

    <section id="transactional.nested">
        <title>Nested transactions</title>
        <para>
            The <literal>org.mybatis.guice.transactional.Transactional</literal>
            annotation is nicely handled to support inner transactional methods;
            given the following simple MyBatis clients:
            <programlisting language="java"><![CDATA[class ServiceA {

    @Transactional
    public void method() {
        ...
    }

}

class ServiceB {

    @Transactional
    public void method() {
        ...
    }

}]]></programlisting>
        </para>
        <para>
            That in a certain point are involved in another one in the same
            transaction:
            <programlisting language="java"><![CDATA[class CompositeService {

    @Inject
    ServiceA serviceA;

    @Inject
    ServiceB serviceB;

    @Transactional
    public void method() {
        ...
        this.serviceA.method();
        ...
        this.serviceB.method();
        ...
    }

}]]></programlisting>
        </para>
        <para>
            In this case, <literal>ServiceA#method()</literal> and
            <literal>ServiceB#method</literal> can be invoked as atomic transactions,
            the advantage is when <literal>serviceA#method()</literal> and
            <literal>serviceB#method()</literal> will be invoked inside the 
            <literal>CompositeService#method</literal>, that the interceptor will
            take care to manage them in the same session, even if annotated to
            start a new transaction.
        </para>
    </section>

</chapter>
