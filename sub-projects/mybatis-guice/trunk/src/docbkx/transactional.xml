<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!--
    Copyright 2010 The myBatis Team

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->

<!--
    version: $Id$
-->
<chapter id="transactional">
    <title>@Transactional</title>

    <section id="transactional.introduction">
        <title>Introduction</title>
        <para>
            Thanks to the excellent combination between <literal>AOP</literal>
            and Google Guice, users can drastically reduce the boilerplate
            code into their DAOs.
        </para>
        <para>
            Let's take in consideration the following code snippet, written
            without introducing mybatis-guice:
            <programlistingco>
                <areaspec>
                    <area id="transactional.example.openSession" coords="15"/>
                    <area id="transactional.example.getFooMapper" coords="18"/>
                    <area id="transactional.example.getBarMapper" coords="21"/>
                    <area id="transactional.example.commitSession" coords="24"/>
                    <area id="transactional.example.rollbackSession" coords="26"/>
                    <area id="transactional.example.throwCustomException" coords="27"/>
                    <area id="transactional.example.closeSession" coords="29"/>
                </areaspec>
                <programlisting language="java"><![CDATA[package com.acme;

import org.apache.ibatis.session.*;
import org.mybatis.guice.transactional.*;

public final class FooDAO {

    private final SqlSessionManager sessionManager;

    public FooDAO(SqlSessionManager sessionManager) {
        this.sessionManager = sessionManager;
    }

    public void doFooBar() throws MyDaoException {
        this.sessionManager.startManagedSession(ExecutorType.BATCH,
            TransactionIsolationLevel.READ_UNCOMMITTED);
        try {
            FooMapper fooMapper = this.sessionManager.getMapper(FooMapper.class);
            fooMapper.doFoo();

            BarMapper barMapper = this.sessionManager.getMapper(BarMapper.class);
            barMapper.doBar();

            this.sessionManager.commit();
        } catch (Throwable t) {
            this.sessionManager.rollback();
            throw new MyDaoException("Something went wrong", t);
        } finally {
            this.sessionManager.close();
        }
    }

}]]></programlisting>
                <calloutlist>
                    <callout arearefs="transactional.example.openSession">
                        <para>Starts a new <literal>SqlSession</literal>.</para>
                    </callout>
                    <callout arearefs="transactional.example.getFooMapper">
                        <para>Retrieve the <literal>FooMapper</literal> and
                        execute the <literal>doFoo()</literal> method.</para>
                    </callout>
                    <callout arearefs="transactional.example.getBarMapper">
                        <para>Same for the <literal>BarMapper</literal>,
                        retrieved from the SqlSession and executed the
                        <literal>doBar()</literal> method.</para>
                    </callout>
                    <callout arearefs="transactional.example.commitSession">
                        <para>If everything gone fine, commit the open session.</para>
                    </callout>
                    <callout arearefs="transactional.example.rollbackSession">
                        <para>If something gone wrong, rollback the open session.</para>
                    </callout>
                    <callout arearefs="transactional.example.throwCustomException">
                        <para>Optionally, throw a proper DAO layer <literal>Exception</literal>.</para>
                    </callout>
                    <callout arearefs="transactional.example.closeSession">
                        <para>Close the session.</para>
                    </callout>
                </calloutlist>
            </programlistingco>
        </para>
        <para>
            Users can easily note that this is a recursive and redundant code
            pattern that mybatis-guice will help to simplify introducing a
            special <literal>AOP</literal> interceptor.
        </para>
    </section>

    <section id="transactional.annotation">
        <title>The @Transactional annotation</title>
        <para>
            Annotating methods with the <literal>org.mybatis.guice.transactional.Transactional</literal>
            annotation, users can eliminate recursive code patterns.
        </para>
        <para>
            First of all, let's have a look at the injector that will create the
            previous <literal>FooDAO</literal> instance:
            <programlisting language="java"><![CDATA[Class<? extends Provider<DataSource>> dataSourceProviderClass = [...];
Class<? extends Provider<TransactionFactory>> txFactoryProviderClass = [...];

Injector injector = Guice.createInjector(new MyBatisModule() {

        @Override
        protected void initialize() {
            environmentId("test");
            bindDataSourceProviderType(dataSourceProviderType);
            bindTransactionFactoryType(txFactoryClass);
            addMapperClass(FooMapper.class);
            addMapperClass(BarMapper.class);
        }

    }
);

FooDAO fooDAO = injector.getInstance(FooDAO.class);]]></programlisting>
        </para>
        <para>
            Where <literal>FooDAO</literal> definition is:
            <programlisting language="java"><![CDATA[package com.acme;

import javax.inject.*;
import org.apache.ibatis.session.*;
import org.mybatis.guice.transactional.*;

@Singleton
public final class FooDAOImpl {

    @Inject
    private FooMapper fooMapper;

    @Inject
    private BarMapper barMapper;

    // let's assume setters here

    @Transactional(
        transactionManagement = TransactionManagement.Managed,
        executorType = ExecutorType.BATCH,
        isolationLevel = TransactionIsolationLevel.READ_UNCOMMITTED,
        rethrowExceptionsAs = MyDaoException.class,
        exceptionMessage = "Something went wrong"
    )
    public void doFooBar() {
        this.fooMapper.doFoo();
        this.barMapper.doBar();
    }

}]]></programlisting>
        </para>
        <para>
            Users can now simply read how the code can be reduced, delegating
            to the interceptor the session management!
        </para>
        <para>
            The <literal>org.mybatis.guice.transactional.Transactional</literal>
            annotation supports the following parameters:
            <table>
                <caption>org.mybatis.guice.transactional.Transactional properties</caption>
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>transactionManagement</td>
                        <td>MyBatis</td>
                        <td>the transaction management policy</td>
                    </tr>
                    <tr>
                        <td>autoCommit</td>
                        <td>false</td>
                        <td>the MyBatis auto commit policy</td>
                    </tr>
                    <tr>
                        <td>executorType</td>
                        <td>ExecutorType.SIMPLE</td>
                        <td>the MyBatis executor type</td>
                    </tr>
                    <tr>
                        <td>isolationLevel</td>
                        <td>TransactionIsolationLevel.NONE</td>
                        <td>the transaction isolation level</td>
                    </tr>
                    <tr>
                        <td>force</td>
                        <td>false</td>
                        <td>Flag to indicate that MyBatis has to force the
                        transaction <literal>commit()</literal></td>
                    </tr>
                    <tr>
                        <td>rethrowExceptionsAs</td>
                        <td>Exception.class</td>
                        <td>rethrow caught exceptions as new Exception
                        (maybe a proper layer exception)</td>
                    </tr>
                    <tr>
                        <td>exceptionMessage</td>
                        <td>empty string</td>
                        <td>A custom error message when throwing the custom exception;
                        it supports <literal>java.util.Formatter</literal>
                        place holders, intercepted method arguments will be used
                        as message format arguments.</td>
                    </tr>
                    <tr>
                        <td>rollbackOnly</td>
                        <td>false</td>
                        <td>If true, the transaction will never committed, but rather the rollback will be forced.
                        That configuration is useful for testing purposes.</td>
                    </tr>
                </tbody>
            </table>
        </para>
        <para>
            When configuring the <literal>@Transactional</literal> annotation
            pay attention on configuring <literal>transactionManagement()</literal>:
            if it is equal to <literal>TransactionManagement.AutoCommit</literal>,
            then the <literal>SqlSession</literal>
            will be started using the <literal>executorType()</literal>
            and <literal>autoCommit()</literal> values; otherwise it if it is equal to
            <literal>TransactionManagement.MyBatis</literal>, <literal>SqlSession</literal>
            will be started using the <literal>executorType()</literal>
            and <literal>isolationLevel()</literal> values.
        </para>
        <para>
            When specifying <literal>rethrowExceptionsAs</literal> parameter,
            it is required that the target exception type has the constructor
            with <literal>Throwable</literal> single argument; when specifying
            both <literal>rethrowExceptionsAs</literal> and <literal>exceptionMessage</literal>
            parameters, it is required that the target exception type has the constructor
            with <literal>String, Throwable</literal> arguments;
            specifying the <literal>exceptionMessage</literal> parameter only
            doesn't have any effect.
        </para>
    </section>

    <section id="transactional.nested">
        <title>Nested transactions</title>
        <para>
            The <literal>org.mybatis.guice.transactional.Transactional</literal>
            annotation is nicely handled to support inner transactional methods;
            given the following simple MyBatis clients:
            <programlisting language="java"><![CDATA[class ServiceA {

    @Transactional
    public void method() {
        ...
    }

}

class ServiceB {

    @Transactional
    public void method() {
        ...
    }

}]]></programlisting>
        </para>
        <para>
            That in a certain point are involved in another one in the same
            transaction:
            <programlisting language="java"><![CDATA[class CompositeService {

    @Inject
    ServiceA serviceA;

    @Inject
    ServiceB serviceB;

    @Transactional
    public void method() {
        ...
        this.serviceA.method();
        ...
        this.serviceB.method();
        ...
    }

}]]></programlisting>
        </para>
        <para>
            In this case, <literal>ServiceA#method()</literal> and
            <literal>ServiceB#method</literal> can be invoked as atomic transactions,
            the advantage is when <literal>serviceA#method()</literal> and
            <literal>serviceB#method()</literal> will be invoked inside the 
            <literal>CompositeService#method</literal>, that the interceptor will
            take care to manage them in the same session, even if annotated to
            start a new transaction.
        </para>
    </section>

</chapter>
