                                    ------
                                    Simple DAO
                                    ------
                                    The myBatis Team
                                    ------
                                     2010

~~
~~   Copyright 2010 The myBatis Team
~~
~~   Licensed under the Apache License, Version 2.0 (the "License");
~~   you may not use this file except in compliance with the License.
~~   You may obtain a copy of the License at
~~
~~       http://www.apache.org/licenses/LICENSE-2.0
~~
~~   Unless required by applicable law or agreed to in writing, software
~~   distributed under the License is distributed on an "AS IS" BASIS,
~~   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~   See the License for the specific language governing permissions and
~~   limitations under the License.
~~

~~version: $Id$

@Transactional

  Using a proper <AOP> interceptor, users can drastically reduce the boilerplate
  code into their DAOs.

  Let's take in consideration the following code snippet:

+--------------------------------------+
package com.acme;

import com.google.inject.Singleton;
import org.mybatis.guice.transactional.*;

import org.apache.ibatis.session.TransactionIsolationLevel;

@Singleton
public final class FooDAOImpl extends AbstractDao implements FooDAO {

    public void doFooBar() throws Exception {
        SqlSession session = this.getSqlSessionFactory().openSession(ExecutorType.BATCH, TransactionIsolationLevel.READ_UNCOMMITTED);
        try {
            FooMapper fooMapper = session.getMapper(FooMapper.class);
            fooMapper.doFoo();

            BarMapper barMapper = session.getMapper(BarMapper.class);
            barMapper.doBar();

            session.commit();
        } catch (Throwable t) {
            session.rollback();
            throw new Exception("Something went wrong", t);
        } finally {
            session.close();
        }
    }

}
+--------------------------------------+

  Introducing the <<<org.mybatis.guice.transactional.AbstractTransactionalDao>>>
  class and the <<<org.mybatis.guice.transactional.Transactional>>> annotation,
  users can eliminate recursive code patterns, transforming the previous method
  in the tidy following:

+--------------------------------------+
package com.acme;

import com.google.inject.Singleton;
import org.mybatis.guice.transactional.*;

import org.apache.ibatis.session.TransactionIsolationLevel;

@Singleton
public final class FooDAOImpl extends AbstractTransactionalDao implements FooDAO {

    @org.mybatis.guice.transactional.Transactional(ExecutorType.BATCH, TransactionIsolationLevel.READ_UNCOMMITTED)
    public void doFooBar() {
        FooMapper fooMapper = this.getMapper(FooMapper.class);
        fooMapper.doFoo();

        BarMapper barMapper = this.getMapper(BarMapper.class);
        barMapper.doBar();
    }

}
+--------------------------------------+

  to obtain this behavior, users have first to bind the interceptor using the
  provided <<<org.mybatis.guice.transactional.TransactionalModule>>> module:

+--------------------------------------+
Class<? extends Provider<DataSource>> dataSourceProviderClass = [...];
Class<? extends Provider<TransactionFactory>> txFactoryProviderClass = [...];

Injector injector = Guice.createInjector(
    new SqlSessionFactoryModule(dataSourceProviderClass, txFactoryProviderClass),
    new Module() {
        public void configure(Binder binder) {
            binder.bind(FooDAO.class).to(FooDAOImpl.class);
        }
    });
);

FooDAO fooDAO = injector.getInstance(FooDAO.class);
+--------------------------------------+

  Then, annotating methods with the <<<org.mybatis.guice.transactional.Transactional>>>
  annotation, that supports the following parameter:

*----------+--------------*----------------*
|| Property || Default     || Description |
*----------+--------------*----------------*
| autoCommit | false | the MyBatis auto commit policy |
*----------+--------------*----------------*
| executorType | org.apache.ibatis.session.ExecutorType.SIMPLE | the MyBatis executor type |
*----------+--------------*----------------*
| isolationLevel | org.apache.ibatis.session.TransactionIsolationLevel.NONE | the transaction isolation level |
*----------+--------------*----------------*
| force | false | Flag to indicate that MyBatis has to force the transaction <<<commit()>>> |
*----------+--------------*----------------*
| rethrowExceptionsAs | Exception.class | rethrow caught exceptions as new Exception (maybe a proper layer exception) |
*----------+--------------*----------------*

  <<Note>> If <<<@org.mybatis.guice.transactional.Transactional.isolationLevel()>>>
  is equals to <<<org.apache.ibatis.session.TransactionIsolationLevel.NONE>>>,
  then the <<<org.apache.ibatis.session.SqlSession>>> will be open using the
  <<<@org.mybatis.guice.transactional.Transactional.executorType()>>> and
  <<<@org.mybatis.guice.transactional.Transactional.autoCommit()>>> values.

  The <<<org.mybatis.guice.transactional.AbstractTransactionalDao>>>
  extends the <<<org.mybatis.guice.transactional.AbstractDao>>>, so users that need
  to use directly the <<<org.apache.ibatis.session.SqlSessionFactory>>> are free
  to use it.

  <<Note>> If, because of your system design, you're not allowed to extends the
  <<<org.mybatis.guice.transactional.AbstractTransactionalDao>>>, but still want to
  enjoy the power of <<<org.mybatis.guice.transactional.Transactional>>>, inject
  into your classes the <<<org.mybatis.guice.transactional.SqlSessionRegistry>>>:

+--------------------------------------+
package com.acme;

import com.google.inject.Singleton;
import org.mybatis.guice.transactional.*;

@Singleton
public final class FooDAOImpl extends MyBarClass implements FooDAO {

    @Inject
    private SqlSessionRegistry sqlSessionRegistry;

    @org.mybatis.guice.transactional.Transactional
    public void doFooBar() {
        FooMapper fooMapper = this.sqlSessionRegistry.getMapper(FooMapper.class);
        fooMapper.doFoo();

        BarMapper barMapper = this.sqlSessionRegistry.getMapper(BarMapper.class);
        barMapper.doBar();
    }

}
+--------------------------------------+

** Nested transactions

  The <<<org.mybatis.guice.transactional.Transactional>>> annotation is nicely
  handled to support inner transactional method declaration; given a simple
  service class:

+--------------------------------------+
class ServiceA {

    @org.mybatis.guice.transactional.Transactional
    public void method() {
        ...
    }

}
+--------------------------------------+

  and another one:

+--------------------------------------+
class ServiceB {

    @org.mybatis.guice.transactional.Transactional
    public void method() {
        ...
    }

}
+--------------------------------------+

  they could be called inside a new composite one:

+--------------------------------------+
class CompositeService {

    ServiceA serviceA;

    ServiceB serviceB;

    @org.mybatis.guice.transactional.Transactional
    public void method() {
        ...
        serviceA.method();
        ...
        serviceB.method();
        ...
    }

}
+--------------------------------------+

  In this case, <<<ServiceA>>> and <<<ServiceB>>> can be used isolatedly, but
  <<<serviceA.method()>>> and <<<serviceB.method()>>> calls in the
  <<<CompositeService>>> will be managed into the same session, even if
  annotated to start a new transaction.
