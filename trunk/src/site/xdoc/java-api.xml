<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2010-2011 The MyBatis Team

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<!--  version: $Id: getting-started.xml 4051 2011-11-25 21:47:24Z simone.tripodi $ -->

<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>MyBatis 3 | Java API</title>
    <author email="mybatis-dev@googlegroups.com">The MyBatis Team</author>
  </properties>

  <body>
  <section name="Java API" id="javaApi">
  <p>Now that you know how to configure MyBatis and create mappings, you're ready for the good stuff.  The MyBatis Java API is where you get to reap the rewards of your efforts.  As you'll see, compared to JDBC, MyBatis greatly simplifies your code and keeps it clean, easy to understand and maintain.  MyBatis 3 has introduced a number of significant improvements to make working with SQL Maps even better.</p>

  <subsection name="Directory Structure" id="directoryStructure">
  <p>Before we dive in to the Java API itself, it's important to understand the best practices surrounding directory structures.  MyBatis is very flexible, and you can do almost anything with your files.  But as with any framework, there's a preferred way.</p>
  <p>Let's look at a typical application directory structure:</p>
  <pre>/my_application
  /bin
  /devlib
  <strong>/lib                <tt>&lt;-- MyBatis *.jar files go here.</tt></strong>
  /src
    /org/myapp/
      /action
      <strong>/data           <tt>&lt;-- MyBatis artifacts go here, including, Mapper Classes, XML Configuration, XML Mapping Files.</tt></strong>
        /SqlMapConfig.xml
        /BlogMapper.java
        /BlogMapper.xml
      /model
      /service
      /view
    <strong>/properties       <tt>&lt;-- Properties included in your XML Configuration go here.</tt></strong>
  /test
    /org/myapp/
      /action
      /data
      /model
      /service
      /view
    /properties
  /web
    /WEB-INF
      /web.xml</pre>
  <p>Remember, these are preferences, not requirements, but others will thank you for using a common directory structure.</p>
  <p>The rest of the examples in this section will assume you're following this directory structure.</p>
  </subsection>  

  <subsection name="SqlSessions" id="sqlSessions">
  <p>The primary Java interface for working with MyBatis is the SqlSession.  Through this interface you can execute commands, get mappers and manage transactions.  We'll talk more about SqlSession itself shortly, but first we have to learn how to acquire an instance of SqlSession. SqlSessions are created by a SqlSessionFactory instance.  The SqlSessionFactory contains methods for creating instances of SqlSessions all different ways.  The SqlSessionFactory itself is created by the SqlSessionFactoryBuilder that can create the SqlSessonFactory from XML, Annotations or hand coded Java configuration.</p>
  <h4>SqlSessionFactoryBuilder</h4>
  <p>The SqlSessionFactoryBuilder has five build() methods, each which allows you to build a SqlSession from a different source.</p>
  <source>SqlSessionFactory build(Reader reader)
SqlSessionFactory build(Reader reader, String environment)
SqlSessionFactory build(Reader reader, Properties properties)
SqlSessionFactory build(Reader reader, String env, Properties props)
SqlSessionFactory build(Configuration config)</source>  

  <p>The first four methods are the most common, as they take a Reader instance that refers to an XML document, or more specifically, the SqlMapConfig.xml file discussed above. The optional parameters are environment and properties.  Environment determines which environment to load, including the datasource and transaction manager. For example:</p>
  
  <source><![CDATA[<environments default="development">
  <environment id="development">
    <transactionManager type="JDBC">
        ...
    <dataSource type="POOLED">
        ...
  </environment>
  <environment id="production">
    <transactionManager type="MANAGED">
        ...
    <dataSource type="JNDI">
        ...
  </environment>
</environments>]]></source>  
  <p>If you call a build method that takes the environment parameter, then MyBatis will use the configuration for that environment.  Of course, if you specify an invalid environment, you will receive an error.  If you call one of the build methods that does not take the environment parameter, then the default environment is uses (which is specified as default="development" in the example above).</p>  
  <p>If you call a method that takes a properties instance, then MyBatis will load those properties and make them available to your configuration.  Those properties can be used in place of most values in the configuration using the syntax:  ${propName}</p>
  <p>Recall that properties can also be referenced from the SqlMapConfig.xml file, or specified directly within it.  Therefore it's important to understand the priority.  We mentioned it earlier in this document, but here it is again for easy reference:</p>

  <blockquote>
  <p>If a property exists in more than one of these places, MyBatis loads them in the following order.</p>
  <ul>
  <li>Properties specified in the body of the properties element are read first,</li>
  <li>Properties loaded from the classpath resource or url attributes of the properties element are read second, and override any duplicate properties already specified,</li>
  <li>Properties passed as a method parameter are read last, and override any duplicate properties that may have been loaded from the properties body and the resource/url attributes.</li>
  </ul>
  <p>Thus, the highest priority properties are those passed in as a method parameter, followed by resource/url attributes and finally the properties specified in the body of the properties element.</p>
  </blockquote>
 
  <p>So to summarize, the first four methods are largely the same, but with overrides to allow you to optionally specify the environment and/or properties.  Here is an example of building a SqlSessionFactory from an SqlMapConfig.xml file. </p>  

  <source>String <strong>resource</strong> = "org/mybatis/builder/MapperConfig.xml";
Reader <strong>reader</strong> = Resources.getResourceAsReader(resource);
SqlSessionFactoryBuilder <strong>builder</strong> = new SqlSessionFactoryBuilder();
SqlSessionFactory <strong>factory</strong> = builder.build(reader);</source>  
  
  <p>Notice that we're making use of the Resources utility class, which lives in the org.mybatis.io package.  The Resources class, as its name implies, helps you load resources from the classpath, filesystem or even a web URL.  A quick look at the class source code or inspection through your IDE will reveal its fairly obvious set of useful methods. Here's a quick list:</p>
  <source>URL getResourceURL(String resource)
URL getResourceURL(ClassLoader loader, String resource)
InputStream getResourceAsStream(String resource)
InputStream getResourceAsStream(ClassLoader loader, String resource)
Properties getResourceAsProperties(String resource)
Properties getResourceAsProperties(ClassLoader loader, String resource)
Reader getResourceAsReader(String resource)
Reader getResourceAsReader(ClassLoader loader, String resource)
File getResourceAsFile(String resource)
File getResourceAsFile(ClassLoader loader, String resource)
InputStream getUrlAsStream(String urlString)
Reader getUrlAsReader(String urlString)
Properties getUrlAsProperties(String urlString)
Class classForName(String className)</source>

  <p>The final build method takes an instance of Configuration.  The Configuration class contains everything you could possibly need to know about a SqlSessionFactory instance.  The Configuration class is useful for introspecting on the configuration, including finding and manipulating SQL maps (not recommended once the application is accepting requests).  The configuration class has every configuration switch that you've learned about already, only exposed as a Java API.  Here's a simple example of how to manually a Configuration instance and pass it to the build() method to create a SqlSessionFactory.</p>
  <source>DataSource dataSource = BaseDataTest.createBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();

Environment environment = new Environment("development", transactionFactory, dataSource);

Configuration configuration = new Configuration(environment);
configuration.setLazyLoadingEnabled(true);
configuration.setEnhancementEnabled(true);
configuration.getTypeAliasRegistry().registerAlias(Blog.class);
configuration.getTypeAliasRegistry().registerAlias(Post.class);
configuration.getTypeAliasRegistry().registerAlias(Author.class);
configuration.addMapper(BoundBlogMapper.class);
configuration.addMapper(BoundAuthorMapper.class);

SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
SqlSessionFactory factory = builder.build(configuration);</source>

  <p>Now you have a SqlSessionFactory that can be used to create SqlSession instances.</p>

  <h4>SqlSessionFactory</h4>
  <p>SqlSessionFactory has six methods that are used to create SqlSessionInstances. In general, the decisions you'll be making when selecting one of these methods are:</p>
  <ul>
    <li><strong>Transaction</strong>: Do you want to use a transaction scope for the session, or use auto-commit (usually means no transaction with most databases and/or JDBC drivers)?</li>
    <li><strong>Connection</strong>: Do you want MyBatis to acquire a Connection from the configured DataSource for you, or do you want to provide your own?</li>
    <li><strong>Execution</strong>: Do you want MyBatis to reuse PreparedStatements and/or batch updates (including inserts and deletes)?</li>
  </ul>
  <p>The set of overloaded openSession() method signatures allow you to choose any combination of these options that makes sense.</p>
  <source>SqlSession openSession()
SqlSession openSession(boolean autoCommit)
SqlSession openSession(Connection connection)
SqlSession openSession(TransactionIsolationLevel level)
SqlSession openSession(ExecutorType execType,TransactionIsolationLevel level)
SqlSession openSession(ExecutorType execType)
SqlSession openSession(ExecutorType execType, boolean autoCommit)
SqlSession openSession(ExecutorType execType, Connection connection)
Configuration getConfiguration();</source>

  <p>The default openSession() method that takes no parameters will create a SqlSession with the following characteristics:</p>
  <ul>
    <li>A transaction scope <u>will</u> be started (i.e. NOT auto-commit).</li>
    <li>A Connection object will be acquired from the DataSource instance configured by the active environment.</li>
    <li>The transaction isolation level will be the default used by the driver or data source.</li>
    <li>No PreparedStatements will be reused, and no updates will be batched.</li>
  </ul>
  <p>Most of the methods are pretty self explanatory. To enable auto-commit, pass a value of “true” to the optional <em>autoCommit</em> parameter. To provide your own connection, pass an instance of Connection to the <em>connection</em> parameter. Note that there's no override to set both the Connection and autoCommit, because MyBatis will use whatever setting the provided connection object is currently using. MyBatis uses a Java enumeration wrapper for transaction isolation levels called, TransactionIsolationLevel, but otherwise they work as expected and have the 5 levels supported by JDBC (NONE, READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE).</p>
  <p>The one parameter that might be new to you is ExecutorType. This enumeration defines 3 values:</p>
  <ul>
    <li><strong>ExecutorType.SIMPLE</strong>: This type of executor does nothing special. It creates a new PreparedStatement for each execution of a statement.</li>
    <li><strong>ExecutorType.REUSE</strong>: This type of executor will reuse PreparedStatements.</li>
    <li><strong>ExecutorType.BATCH</strong>: This executor will batch all update statements and demarcate them as necessary if SELECTs are executed between them, to ensure an easy-to-understand behavior.</li>
  </ul>
  <p><span class="label important">NOTE</span> There's one more method on the SqlSessionFactory that we didn't mention, and that is <em>getConfiguration()</em>. This method will return an instance of Configuration that you can use to introspect upon the MyBatis configuration at runtime.</p>
  <p><span class="label important">NOTE</span> If you've used a previous version of MyBatis, you'll recall that sessions, transactions and batches were all something separate. This is no longer the case. All three are neatly contained within the scope of a session. You need not deal with transactions or batches separately to get the full benefit of them.</p>

  <h4>SqlSession</h4>
  <p>As mentioned above, the SqlSession instance is the most powerful class in MyBatis. It is where you'll find all of the methods to execute statements, commit or rollback transactions and acquire mapper instances.</p>
  <p>There are over twenty methods on the SqlSession class, so let's break them up into more digestible groupings.</p>

  <h5>Statement Execution Methods</h5>
  <p>These methods are used to execute SELECT, INSERT, UPDATE and DELETE statements that are defined in your SQL Mapping XML files. They are pretty self explanatory, each takes the ID of the statement and the Parameter Object, which can be a primitive (auto-boxed or wrapper), a JavaBean, a POJO or a Map.</p>
  <source>Object selectOne(String statement, Object parameter)
List selectList(String statement, Object parameter)
Map selectMap(String statement, Object parameter, String mapKey)
int insert(String statement, Object parameter)
int update(String statement, Object parameter)
int delete(String statement, Object parameter)</source>
  <p>The difference between selectOne and selectList is only in that selectOne must return exactly one object or null (none). If any more than one, an exception will be thrown. If you don't' know how many objects are expected, use selectList. If you want to check for the existence of an object, you're better off returning a count (0 or 1). The selectMap is a special case in that it is designed to convert a list of results into a Map based on one of the properties in the resulting objects. Because not all statements require a parameter, these methods are overloaded with versions that do not require the parameter object.</p>
  <source>Object selectOne(String statement)
List selectList(String statement)
Map selectMap(String statement, String mapKey)
int insert(String statement)
int update(String statement)
int delete(String statement)</source>

  <p>Finally, there are three advanced versions of the select methods that allow you to restrict the range of rows to return, or provide custom result handling logic, usually for very large data sets.</p>
  <source>List selectList (String statement, Object parameter, RowBounds rowBounds)
Map selectMap(String statement, Object parameter, String mapKey, RowBounds rowbounds)
void select (String statement, Object parameter, ResultHandler handler)
void select (String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</source>

  <p>The RowBounds parameter causes MyBatis to skip the number of records specified, as well as limit the number of results returned to some number. The RowBounds class has a constructor to take both the offset and limit, and is otherwise immutable.</p> 
  <source>int offset = 100;
int limit = 25;
RowBounds rowBounds = new RowBounds(offset, limit);</source>

  <p>Different drivers are able to achieve different levels of efficiency in this regard. For the best performance, use result set types of SCROLL_SENSITIVE or SCROLL_INSENSITIVE (in other words: not FORWARD_ONLY).</p>
  <p>The ResultHandler parameter allows you to handle each row however you like. You can add it to a List, create a Map, Set, or throw each result away and instead keep only rolled up totals of calculations. You can do pretty much anything with the ResultHandler, and it's what MyBatis uses internally itself to build result set lists.</p>
  <p>The interface is very simple.</p>  
  <source>package org.mybatis.executor.result;
public interface ResultHandler {
  void handleResult(ResultContext context);
}</source>

  <p>The ResultContext parameter gives you access to the result object itself, a count of the number of result objects created, and a Boolean stop() method that you can use to stop MyBatis from loading any more results.</p>

  <h5>Transaction Control Methods</h5>
  <p>There are four methods for controlling the scope of a transaction. Of course, these have no effect if you've chosen to use auto-commit or if you're using an external transaction manager. However, if you're using the JDBC transaction manager, managed by the Connection instance, then the four methods that will come in handy are:</p>
  <source>void commit()
void commit(boolean force)
void rollback()
void rollback(boolean force)</source>
  <p>By default MyBatis does not actually commit unless it detects that the database has been changed by a call to insert, update or delete. If you've somehow made changes without calling these methods, then you can pass true into the commit and rollback methods to guarantee that it will be committed (note, you still can't force a session in auto-commit mode, or one that is using an external transaction manager). Most of the time you won't have to call rollback(), as MyBatis will do that for you if you don't call commit. However, if you need more fine grained control over a session where multiple commits and rollbacks are possible, you have the rollback option there to make that possible.</p>
  
  <h5>Clearing the Session Level Cache</h5>
  <source>void clearCache()</source>
  <p>The SqlSession instance has a local cache that is cleared upon update, commit, rollback and close. To clear it explicitly (perhaps with the intention to do more work), you can call clearCache().</p>

  <h5>Ensuring that SqlSession is Closed</h5>
  <source>void close()</source>
  <p>The most important thing you must ensure is that you close any sessions that you open. The best way to ensure this is to use the following unit of work pattern:</p>
  <source>SqlSession session = sqlSessionFactory.openSession();
try {
    // following 3 lines pseudocod for "doing some work"
    session.insert(...);
    session.update(...);
    session.delete(...);
    session.commit();
} finally {
    session.close();
}</source>
  <p><span class="label important">NOTE</span> Just like SqlSessionFactory, you can get the instance of Configuration that the SqlSession is using by calling the getConfiguration() method.</p>
  <source>Configuration getConfiguration()</source>

  <h5>Using Mappers</h5>
  <source><![CDATA[<T> T getMapper(Class<T> type)]]></source>  
  <p>While the various insert, update, delete and select methods above are powerful, they are also very verbose, not type safe and not as helpful to your IDE or unit tests as they could be. We've already seen an example of using Mappers in the Getting Started section above.</p>
  <p>Therefore, a more common way to execute mapped statements is to use Mapper classes. A mapper class is simply an interface with method definitions that match up against the SqlSession methods. The following example class demonstrates some method signatures and how they map to the SqlSession.</p>
  <source><![CDATA[public interface AuthorMapper {
  // (Author) selectOne("selectAuthor",5);
  Author selectAuthor(int id); 
  // (List<Author>) selectList(“selectAuthors”)
  List<Author> selectAuthors();
  
  // (Map<Integer,Author>) selectMap("selectAuthors", "id")
  @MapKey("id")
  List<Author> selectAuthorsAsMap();
  // insert("insertAuthor", author)
  int insertAuthor(Author author);
  // updateAuthor("updateAuthor", author)
  int updateAuthor(Author author);
  // delete("deleteAuthor",5)
  int deleteAuthor(int id);
}]]></source>
  <p>In a nutshell, each Mapper method signature should match that of the SqlSession method that it's associated to, but without the String parameter ID. Instead, the method name must match the mapped statement ID.</p> 
  <p>In addition, the return type must match that of the expected result type. All of the usual types are supported, including: Primitives, Maps, POJOs and JavaBeans.</p>
  <p><span class="label important">NOTE</span> Mapper interfaces do not need to implement any interface or extend any class. As long as the method signature can be used to uniquely identify a corresponding mapped statement.</p>
  <p><span class="label important">NOTE</span> Mapper interfaces can extend other interfaces. Be sure that you have the statements in the appropriate namespace when using XML binding to Mapper interfaces. Also, the only limitation is that you cannot have the same method signature in two interfaces in a hierarchy (a bad idea anyway).</p>
  <p>You can pass multiple parameters to a mapper method. If you do, they will be named by their position in the parameter list by default, for example: #{1}, #{2} etc. If you wish to change the name of the parameters (multiple only), then you can use the @Param("paramName") annotation on the parameter.</p>
  <p>You can also pass a RowBounds instance to the method to limit query results.</p>

  <h5>Mapper Annotations</h5>
  <p>Since the very beginning, MyBatis has been an XML driven framework. The configuration is XML based, and the Mapped Statements are defined in XML. With MyBatis 3, there are new options available. MyBatis 3 builds on top of a comprehensive and powerful Java based Configuration API. This Configuration API is the foundation for the XML based MyBatis configuration, as well as the new Annotation based configuration. Annotations offer a simple way to implement simple mapped statements without introducing a lot of overhead.</p>
  <p><span class="label important">NOTE</span> Java Annotations are unfortunately limited in their expressiveness and flexibility. Despite a lot of time spent in investigation, design and trials, the most powerful MyBatis mappings simply cannot be built with Annotations – without getting ridiculous that is. C# Attributes (for example) do not suffer from these limitations, and thus MyBatis.NET will enjoy a much richer alternative to XML. That said, the Java Annotation based configuration is not without its benefits.</p>
  <p><strong>The Annotations are as follows:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Annotation</th>
        <th>Target</th>
        <th>XML equivalent</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>@CacheNamespace</td>
        <td>Class</td>
        <td>&lt;cache&gt;</td>
        <td>Configures the cache for the given namespace (i.e. class). Attributes: <strong>implementation, eviction, flushInterval, size, readWrite</strong>.</td>
      </tr>
      <tr>
        <td>@CacheNamespaceRef</td>
        <td>Class</td>
        <td>&lt;cacheRef&gt;</td>
        <td>References the cache of another namespace to use. Attributes: <strong>value</strong>, which should be the string value of a namespace (i.e. a fully qualified class name).</td>
      </tr>
      <tr>
        <td>@ConstructorArgs</td>
        <td>Method</td>
        <td>&lt;constructor&gt;</td>
        <td>Collects a group of results to be passed to a result object constructor. Attributes: <strong>value</strong>, which is an array of Args.</td>
      </tr>
      <tr>
        <td>@Arg</td>
        <td>Method</td>
        <td>&lt;arg&gt;<br/>&lt;idArg&gt;</td>
        <td>A single constructor argument that is part of a ConstructorArgs collection. Attributes: <strong>id, column, javaType, jdbcType, typeHandler, select, resultMap</strong>. The id attribute is a boolean value that identifies the property to be used for comparisons, similar to the &lt;idArg&gt; XML element.</td>
      </tr>
      <tr>
        <td>@TypeDiscriminator</td>
        <td>Method</td>
        <td>&lt;discriminator&gt;</td>
        <td>A group of value cases that can be used to determine the result mapping to perform. Attributes: <strong>column, javaType, jdbcType, typeHandler, cases</strong>. The cases attribute is an array of Cases.</td>
      </tr>
      <tr>
        <td>@Case</td>
        <td>Method</td>
        <td>&lt;case&gt;</td>
        <td>A single case of a value and its corresponding mappings. Attributes: <strong>value, type, results</strong>. The results attribute is an array of Results, thus this Case Annotation is similar to an actual ResultMap, specified by the Results annotation below.</td>
      </tr>
      <tr>
        <td>@Results</td>
        <td>Method</td>
        <td>&lt;resultMap&gt;</td>
        <td>A list of Result mappings that contain details of how a particular result column is mapped to a property or field. Attributes: <strong>value</strong>, which is an array of Result annotations.</td>
      </tr>
      <tr>
        <td>@Result</td>
        <td>Method</td>
        <td>&lt;result&gt;<br/>&lt;id&gt;</td>
        <td>A single result mapping between a column and a property or field. Attributes: <strong>id, column, property, javaType, jdbcType, typeHandler, one, many</strong>. The id attribute is a boolean value that indicates that the property should be used for comparisons (similar to &lt;id&gt; in the XML mappings). The one attribute is for single associations, similar to &lt;association&gt;, and the many attribute is for collections, similar to &lt;collection&gt;. They are named as they are to avoid class naming conflicts.</td>
      </tr>
      <tr>
        <td>@One</td>
        <td>Method</td>
        <td>&lt;association&gt;</td>
        <td>A mapping to a single property value of a complex type. Attributes: <strong>select</strong>, which is the fully qualified name of a mapped statement (i.e. mapper method) that can load an instance of the appropriate type. <span class="label important">NOTE</span> You will notice that join mapping is not supported via the Annotations API. This is due to the limitation in Java Annotations that does not allow for circular references.</td>
      </tr>
      <tr>
        <td>@Many</td>
        <td>Method</td>
        <td>&lt;collection&gt;</td>
        <td>A mapping to a collection property of a complex type. Attributes: <strong>select</strong>, which is the fully qualified name of a mapped statement (i.e. mapper method) that can load a collection of instances of the appropriate types. <span class="label important">NOTE</span> You will notice that join mapping is not supported via the Annotations API. This is due to the limitation in Java Annotations that does not allow for circular references.</td>
      </tr>
      <tr>
        <td>@MapKey</td>
        <td>Method</td>
        <td> </td>
        <td>This is used on methods which return type is a Map. It is used to convert a List of result objects as a Map based on a property of those objects.</td>
      </tr>
      <tr>
        <td>@Options</td>
        <td>Method</td>
        <td>Attributes of mapped statements.</td>
        <td>This annotation provides access to the wide range of switches and configuration options that are normally present on the mapped statement as attributes. Rather than complicate each statement annotation, the Options annotation provides a consistent and clear way to access these. Attributes: <strong>useCache=true, flushCache=false, resultSetType=FORWARD_ONLY, statementType=PREPARED, fetchSize=-1, timeout=-1, useGeneratedKeys=false, keyProperty="id", keyColumn=""</strong>. It's important to understand that with Java Annotations, there is no way to specify "null" as a value. Therefore, once you engage the Options annotation, your statement is subject to all of the default values. Pay attention to what the default values are to avoid unexpected behavior.<br/><br/>Note that keyColumn is only required in certain databases (like Oracle and PostgreSQL). See the discussion about keyColumn and keyProperty above in the discussion of the insert statement for more information about allowable values in these attributes.</td>
      </tr>
      <tr>
        <td>@Insert<br/>@Update<br/>@Delete<br/>@Select</td>
        <td>Method</td>
        <td>&lt;insert&gt;<br/>&lt;update&gt;<br/>&lt;delete&gt;<br/>&lt;select&gt;</td>
        <td>Each of these annotations represents the actual SQL that is to be executed. They each take an array of strings (or a single string will do). If an array of strings is passed, they are concatenated with a single space between each to separate them. This helps avoid the "missing space" problem when building SQL in Java code. However, you're also welcome to concatenate together a single string if you like. Attributes: <strong>value</strong>, which is the array of Strings to form the single SQL statement.</td>
      </tr>
      <tr>
        <td>@InsertProvider<br/>@UpdateProvider<br/>@DeleteProvider<br/>@SelectProvider</td>
        <td>Method</td>
        <td>&lt;insert&gt;<br/>&lt;update&gt;<br/>&lt;delete&gt;<br/>&lt;select&gt;</td>
        <td>Allows for creation of dynamic SQL.	These alternative SQL annotations allow you to specify a class name and a method that will return the SQL to run at execution time. Upon executing the mapped statement, MyBatis will instantiate the class, and execute the method, as specified by the provider. <u>The method can optionally accept the parameter object as its sole parameter, but must only specify that parameter, or no parameters</u>. Attributes: <strong>type, method</strong>. The type attribute is the fully qualified name of a class. The method is the name of the method on that class. <span class="label important">NOTE</span> Following this section is a discussion about the SelectBuilder class, which can help build dynamic SQL in a cleaner, easier to read way.</td>
      </tr>
      <tr>
        <td>@Param</td>
        <td>Parameter</td>
        <td>N/A</td>
        <td>If your mapper method takes multiple parameters, this annotation can be applied to a mapper method parameter to give each of them a name. Otherwise, multiple parameters will be named by their ordinal position (not including any RowBounds parameters). For example #{1}, #{2} etc. is the default. With @Param("person"), the parameter would be named #{person}.</td>
      </tr>
      <tr>
        <td>@SelectKey</td>
        <td>Method</td>
        <td>&lt;selectKey&gt;</td>
        <td>This annotation duplicates the &lt;selectKey&gt; functionality for methods annotated with @Insert or @InsertProvider. It is ignored for other methods. If you specify a @SelectKey annotation, then MyBatis will ignore any generated key properties set via the @Options annotation, or configuration properties. Attributes: statement an array of strings which is the SQL statement to execute, keyProperty which is the property of the parameter object that will be updated with the new value, before which must be either true or false to denote if the SQL statement should be executed before or after the insert, resultType which is the Java type of the keyProperty, and statementType=PREPARED.</td>
      </tr>
      <tr>
        <td>@ResultMap</td>
        <td>Method</td>
        <td>N/A</td>
        <td>This annotation is used to provide the id of a &lt;resultMap&gt; element in an XML mapper to a @Select or @SelectProvider annotation. This allows annotated selects to reuse resultmaps that are defined in XML. This annotation will override any @Results or @ConstructorArgs annotation if both are specified on an annotated select.</td>
      </tr>
    </tbody>
  </table>

  <h5>Mapper Annotation Examples</h5>
  <p>This example shows using the @SelectKey annotation to retrieve a value from a sequence before an insert:</p>
  <source>@Insert("insert into table3 (id, name) values(#{nameId}, #{name})")
@SelectKey(statement="call next value for TestSequence", keyProperty="nameId", before=<strong>true</strong>, resultType=<strong>int.class</strong>)
<strong>int</strong> insertTable3(Name name);</source>

  <p>This example shows using the @SelectKey annotation to retrieve an identity value after an insert:</p>
  <source>@Insert("insert into table2 (name) values(#{name})")
@SelectKey(statement="call identity()", keyProperty="nameId", before=<strong>false</strong>, resultType=<strong>int.class</strong>)
<strong>int</strong> insertTable2(Name name);</source>
  </subsection>  
  </section>
  </body>
</document>
